package edu.umb.testutils;

import edu.umb.testutils.BuilderFaces.*;

import org.junit.platform.launcher.Launcher;
import org.junit.platform.launcher.LauncherDiscoveryRequest;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
import org.junit.platform.launcher.core.LauncherFactory;
import org.junit.platform.launcher.listeners.SummaryGeneratingListener;
import org.junit.platform.launcher.listeners.TestExecutionSummary;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.*;

import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
import static org.junit.platform.launcher.EngineFilter.excludeEngines;

public class TestFactory {
    private static final Level loggingLevel = Level.FINER;
    private static final Logger logger;
    private static TestFactory instance;
    private final HashMap<Integer, Test> tests;
    private final FactoryProperties props;
    private int testNumber;

    static {
        Logger.getLogger("").setLevel(Level.OFF);
        Logger.getLogger("").getHandlers()[0].setLevel(Level.OFF);
        Logger.getLogger("edu").setLevel(Level.OFF);
        Logger.getLogger("edu.umb").setLevel(Level.OFF);

        Logger parent = Logger.getLogger("edu.umb.testutils");
        LogFormatter formatter = new LogFormatter();
        Handler handler = new ConsoleHandler();
        handler.setFormatter(formatter);
        handler.setLevel(Level.INFO);
        parent.setLevel(Level.FINEST);
        parent.addHandler(handler);
        try {
            FileHandler fh = new FileHandler("/autograder/log.txt");
            fh.setFormatter(formatter);
            fh.setLevel(Level.FINEST);
            parent.addHandler(fh);
        } catch (IOException e) {
            e.printStackTrace();
        }

        logger = Logger.getLogger(TestFactory.class.getName());
        logger.info(String.format("TestFactory Logger online. level %s. Parent %s, level: %s",
                logger.getLevel(), logger.getParent(), logger.getParent().getLevel()));
    }

    /**
     * Constructs a new TestFactory object used to build tests. This constructor should be
     * used when the student class files do not belong to any package.
     *
     * Default logging level "INFO" is used.
     */
    public TestFactory() { this("", loggingLevel); }

    /**
     * Constructs a new TestFactory object used to build tests. This constructor should be
     * used when the student class files do not belong to any package and a log level
     * is to be specified.
     *
     * @param level the logging level to use for the logger
     */
    public TestFactory(Level level) { this("", level); }

    /**
     * Constructs a new TestFactory object used to build tests. This constructor should be
     * used when the student class files belong to some package.
     *
     * Default logging level "INFO" is used.
     *
     * @param packageName the fully qualified package name
     */
    public TestFactory(String packageName) { this(packageName, loggingLevel); }

    /**
     * Constructs a new TestFactory object used to build tests. This constructor should be
     * used when the student class files belong to some package and when a certain log level
     * is desired.
     *
     * @param packageName the fully qualified package name
     * @param level the log level to use for this factory
     */
    public TestFactory(String packageName, Level level) {
        Logger parent = Logger.getLogger("edu.umb.testutils");
        parent.setLevel(level);
//        parent.getHandlers()[0].setLevel(level);

        TestUtils.setPackageName(packageName);
        tests = new HashMap<>();
        TestListener.setMessageFlag("({{<<=:o:=>>}})", tests);
        testNumber = 0;
        props = new FactoryProperties();
        instance = this;
        TestBuilder.initFactory(this);

        logger.info(String.format("TestFactory instantiated. level %s. Parent %s, level: %s",
                logger.getLevel(), logger.getParent(), logger.getParent().getLevel()));
    }

    /**
     * Changes the maximum score of all tests generated using this factory. This score
     * is the normalized total score. Example: The default is 60, meaning a student who gets
     * 100% correct will get a 60/60. Changing this number to 90 will make a student who gets
     * 100% receive a 90/90 instead.
     * @param newMax the new max score for all tests generated by this factory
     */
    public void setMaxTestScore(double newMax) {
        TestUtils.setMaxTestScore(newMax);
    }

    /* ****************************************************************************************** */
    /* Methods used by the user to build tests */
    /* ****************************************************************************************** */

    /**
     * Prepares a partial test using previously set test properties. The user must finish
     * setting up the test by calling the available builder methods on the returned
     * {@link TestBuilder} object. The minimum required properties to be set are
     * name, className, testType, and maxScore. Usage example:
     *
     * <pre>
     * {@code
     * TestFactory factory = new TestFactory();
     * factory.props().name("My Test Name");
     * factory.props().className("MyClass");
     * factory.props().testingReturnValue();
     * factory.props().maxScore(1);
     * factory.preparedTest().withConstructorArgs(someValue).forMethod("someTest")...;
     * factory.preparedTest().withConstructorArgs(someValue).forMethod("differentMethod")...;
     * }
     * </pre>
     * @return the partially prepared test
     * @throws UnpreparedTestException if the minimum required properties are not set
     */
    public PreparedTest preparedTest() throws UnpreparedTestException {
        return TestBuilder.preparedTest();
    }

    /**
     * Prepares an partial test using previously set test properties, with the added ability
     * to initialize the class object being tested. The user must call the
     * {@link TwoStepTestStart#initialize()} method to gain access to additional setup methods.
     * After initialization, the user may call {@link TestFactory#twoStepTestFinish()}
     * repeatedly to create multiple tests using the same initialized object.
     * Usage example:
     *
     * <pre>
     * {@code
     * TestFactory factory = new TestFactory();
     * ...
     * factory.twoStepTestStart().initialize().callMethod("someMethod").withArgs(someArg);
     * factory.twoStepTestFinish()...
     * factory.twoStepTestFinish()...
     * }
     * </pre>
     *
     * You may also pass a lambda expression to initialize the class object, allowing for
     * more complex initialization procedures such as loops. Here is an example which reads
     * data from a file, then calls a method using that data:
     *
     * <pre>
     * {@code
     * TestFactory.SetupFunction setup = (obj, arg) -> {
     *     In in = (In) arg[0];
     *     while (!in.isEmpty()) {
     *         obj.callMethod("open").withArgs(in.readInt(), in.readInt());
     *     }
     * };
     * In inputReader = new In("data/someDataFile.txt");
     * TestFactory factory = new TestFactory();
     * ...
     * factory.twoStepTestStart().initialize().using(setup, inputReader);
     * factory.twoStepTestFinish()...
     * factory.twoStepTestFinish()...
     * }
     * </pre>
     *
     * @return the first part of a partially prepared test
     * @throws UnpreparedTestException if the minimum required properties are not set
     * @see TestFactory#preparedTest() preparedTest()
     */
    public TwoStepTestStart twoStepTestStart() throws UnpreparedTestException {
        return TestBuilder.twoStepTestStart();
    }

    /**
     * Returns the partially complete test with the class object that was initialized using
     * {@link TestFactory#twoStepTestStart()}. The user must finish setting up the test
     * by using the available method chain. This method may be called more than once to create
     * multiple tests using the same initialized class object. Usage example:
     *
     * <pre>
     * see {@link TestFactory#twoStepTestStart()} for setup details
     * {@code
     * ...
     * factory.twoStepTestStart().initialize().using(setup, inputReader);
     * factory.twoStepTestFinish().method("someMethod").methodArgs(someArgs).build();
     * factory.twoStepTestFinish().method("someMethod").methodArgs(otherArgs).build();
     * factory.twoStepTestFinish().method("otherMethod").methodArgs().build();
     * }
     * </pre>
     *
     * @return the second part of a partially prepared test
     * @throws UnpreparedTestException if constructor arguments have not been set
     */
    public TwoStepTestFinish twoStepTestFinish() throws UnpreparedTestException {
        return TestBuilder.twoStepTestFinish();
    }

    /**
     * Prepares and builds a checkstyle test on the .java file of the given className. No
     * further setup is needed after calling this method. It is assumed that the source file
     * is located inside the /autograder/submission folder on Gradescope.
     * @param className the name of the class to be checked
     */
    public void createStyleTest(String className) {
        TestBuilder.createStyleTest(className);
    }

    /**
     * Prepares and builds a checkstyle test on the .java file of the given className. No
     * further setup is needed after calling this method. It is assumed that the source file
     * is located inside the /autograder/submission folder on Gradescope.
     * @param className the name of the class to be checked
     * @param value the point value of this style test
     */
    public void createStyleTest(String className, double value) {
        TestBuilder.createStyleTest(className, value);
    }

    /**
     * Prepares and builds a 0 point test that checks for the existence of a file in the
     * submission folder. This is generally used to warn students if they forgot
     * to upload a report.txt file.
     *
     * @param fileName the name of the file to check for existence
     */
    public void createFileExistenceTest(String fileName) {
        TestBuilder.createFileExistenceTest(fileName);
    }

    /**
     * Returns an {@link ArgBuilder} instance used to create an object argument to a method
     * or constructor under test. This should only be used to create objects of submitted
     * classes. Generic java objects may be instantiated directly. Usage example:
     *
     * <pre>
     * see {@link TestFactory#preparedTest()} for setup details
     * {@code
     * ...
     * factory.preparedTest().withMethodArgs(
     *     factory.createObjectArg().ofClass("someClass").withArgs(arg1, arg2)
     * ).build;
     * }
     * </pre>
     *
     * @return the {@link ArgBuilder} used to construct the object argument
     */
    public ArgClass createObjectArg() {
        return ArgBuilder.createObjectArg();
    }

    public ArgObject createObjectArg(Object expectArg, Object actualArg) {
        return ArgBuilder.createObjectArg(expectArg, actualArg);
    }

    /* ****************************************************************************************** */
    /* package helper methods */
    /* ****************************************************************************************** */

    static Collection<Test> getTests() { return instance.tests.values(); }

    void addTest(Test test) {
        test.setNumber(++testNumber);
        tests.put(test.getNumber(), test);
    }

    /* ****************************************************************************************** */
    /* Test Function Section */
    /* ****************************************************************************************** */

    static TestFunctionRunner testUsing(Test test) {
        return new TestFunctionRunner(test);
    }

    @FunctionalInterface
    public interface TestFunction { void runTest(TestFunctionRunner obj, Object... args); }

    public static class TestFunctionRunner {
        private final Test test;
        private Object expectObj;
        private Object actualObj;
        private TestFunctionRunner(Test test) {
            this.test = test;
            expectObj = test.getExpectClassInstance();
            actualObj = test.getActualClassInstance();
        }

        public void using(TestFunction function, Object... args) {
            function.runTest(this, args);
        }

        public TestFunctionRunner getIterators() {
            if (test.getActualClassInstance() instanceof Iterable) {
                expectObj = ((Iterable<?>)test.getExpectClassInstance()).iterator();
                actualObj = ((Iterable<?>)test.getActualClassInstance()).iterator();
            }
            return this;
        }

    }

    /* ****************************************************************************************** */
    /* ArgObject initialization section */
    /* ****************************************************************************************** */

    static ArgSetup setup(ArgBuilder arg) {
        return new ArgSetup(arg);
    }

    @FunctionalInterface
    public interface ArgSetupFunction {
        ArgObject setup(ArgSetup obj, Object... args);
    }

//    public interface ArgMethodCall    {
//        /**
//         * Sets the arguments to be used during the object initialization step of creating tests.
//         * This method should be called after the {@link ArgSetup#callMethod(String)} method
//         * is called.
//         *
//         * @param args the arguments to be used when calling the method specified
//         * @return the {@link ArgSetup} object used to initialize the argument
//         */
//        ArgSetup withArgs(Object... args);
//    }

    public static class ArgSetup {
        private final ArgBuilder arg;
        private ArgSetup(ArgBuilder arg) {
            this.arg = arg;
        }

        public ArgObject using(ArgSetupFunction function, Object... args) {
            return function.setup(this, args);
        }


        public ArgObject replaceInstanceWithReturnFromMethod(String methodName, Object... args) {
            Object expectObj = arg.getExpectInstance();
            Object actualObj = arg.getActualInstance();
            Method expectMethod = TestUtils.getMethod(expectObj.getClass(), methodName, args);
            Method actualMethod = actualObj == null ? null :
                    TestUtils.getMethod(actualObj.getClass(), methodName, args);
            Object expectNewObj = TestUtils.callMethodAndReturn(expectObj, expectMethod, args);
            Object actualNewObj = actualMethod == null ? null :
                    TestUtils.callMethodAndReturn(actualObj, actualMethod, args);
//            sb.append("   Retrieving the object returned by a call to the <")
//                    .append(methodName).append("> method\n    ");
//            String argString = TestUtils.argArray2String(TestUtils.parseActualMethodArgs(args));
//            sb.append(argString).append("\n");
            return ArgBuilder.createObjectArg(expectNewObj, actualNewObj);
        }

        public ArgSetup setFieldValue(String fieldName, ArgObject value) {
            arg.setFieldValue(fieldName, value);
            return this;
        }

        public ArgSetup setFieldValue(String fieldName, Object value) {
            arg.setFieldValue(fieldName, value);
            return this;
        }

        public ArgObject getArgObject() { return arg; }
    }

    /* ****************************************************************************************** */
    /* Object initialization section */
    /* ****************************************************************************************** */

    static TestSetup setup(TestBuilder test, StringBuilder sb) {
        return new TestSetup(test, sb);
    }

    public interface MethodCall    {
        /**
         * Sets the arguments to be used during the object initialization step of creating tests.
         * This method should be called after the {@link TestSetup#callMethod(String)} method
         * is called.
         *
         * @param args the arguments to be used when calling the method specified
         * @return the {@link TestSetup} object used to initialize the class object
         */
        TestSetup withArgs(Object... args);
    }

    /**
     * Functional interface used during object initialization. Writing a custom setup
     * function is the alternative to using the callMethod().withArgs() method chain.
     *
     * Example usage:
     * <pre>
     * {@code
     * TestFactory.SetupFunction setup = (obj, arg) -> {
     *     In in = (In) arg[0];
     *     while (!in.isEmpty()) {
     *         obj.callMethod("open").withArgs(in.readInt(), in.readInt());
     *     }
     * };
     * In inputReader = new In("data/someDataFile.txt");
     * TestFactory factory = new TestFactory();
     * ...
     * factory.twoStepTestStart().initialize().using(setup, inputReader);
     * factory.twoStepTestFinish()...
     * factory.twoStepTestFinish()...
     * }
     * </pre>
     */
    @FunctionalInterface
    public interface SetupFunction { void setup(TestSetup obj, Object... args); }

    public static class TestSetup implements MethodCall {
        private final TestBuilder builder;
        private final StringBuilder sb;
        private int steps;
        private int maxSteps = 24;
        private HashMap<String, Integer> calls;
        private boolean usingIterator;
        private TestSetup(TestBuilder builder, StringBuilder sb) {
            logger.finer("Object setup will be done using a TestSetup object");
            this.builder = builder;
            this.sb = sb;
            steps = 0;
            calls = new HashMap<>();
            usingIterator = false;
            if (!builder.hasFailed()) {
                sb.append("Setting up the class object using the following steps:\n");
            }
        }

        /**
         * Executes the {@link SetupFunction} using the given arguments. This method should be
         * used when the user requires more complicated setup steps for the object being tested.
         * For example, when a loop is required to initialize a set of data.
         *
         * @param function the function to be used to set up the class object
         * @param args the arguments required during setup
         * @return the TestSetup object used to call this method
         */
        public TestSetup using(SetupFunction function, Object... args) {
            logger.finer("Setting up class object using a lambda function");
            if (builder.hasFailed()) {
                logger.fine("Could not set up as test has already failed.");
                return this;
            }
            function.setup(this, args);
            return this;
        }

        /**
         * Calls the given method belonging to the class being tested. This method call should
         * be followed by a call to {@link TestSetup#withArgs(Object...)}.
         *
         * @param method the method to be called
         * @return the object used to chain with a call to withArgs()
         */
        public MethodCall callMethod(String method) {
            logger.finer(String.format("Setting up class object by calling %s()", method));
            if (builder.hasFailed()) {
                logger.fine(String.format("Could not call %s() as test has already failed.", method));
                return this;
            }
            steps++;
            calls.put(method, calls.getOrDefault(method, 0)+1);
            if (steps > maxSteps) {
                sb.delete(0, sb.length());
                sb.append("Setting up the class object using the following steps:\n");
                if (usingIterator) sb.append("   Retrieving the class's iterator\n");
                for (Map.Entry<String, Integer> curr : calls.entrySet()) {
                    sb.append(String.format("   Calling <%s> a total of %s times\n",
                            curr.getKey(), curr.getValue()));
                }
            } else {
                sb.append("   Calling the <").append(method).append("> method ");
            }
            builder.callMethod(method);
            return this;
        }
        @Override
        public TestSetup withArgs(Object... args) {
            logger.finer("Set up by specifying the arguments (omitted)");
            if (builder.hasFailed()) {
                logger.fine("Could not specify method args as test has already failed.");
                return this;
            }
            if (!(steps > maxSteps)) {
                String argString = TestUtils.argArray2String(TestUtils.parseActualArgs(args));
                sb.append(argString).append("\n");
            }
            builder.withArgs(args);
            return this;
        }

        /**
         * Causes this test to use the class's iterator object instead of the class object itself.
         * Test will fail if the submitted class does not implement the Iterable interface.
         * @return the TestSetup object used to call this method
         */
        public TestSetup replaceInstanceWithIterator() {
            logger.fine("Replacing current instance with its iterator");
            if (builder.hasFailed()) {
                logger.fine("Could not replace instance as test has already failed.");
                return this;
            }
            sb.append("   Retrieving the class's iterator\n");
            Object expectObj = builder.getExpectClassInstance();
            Object actualObj = builder.getActualClassInstance();
            if (actualObj instanceof Iterable) {
                usingIterator = true;
                builder.setInstanceToIterator();
            } else {
                logger.info("Test failed due to current instance not being Iterable");
                builder.setFailed(actualObj.getClass() + " does not implement Iterable interface");
            }
            return this;
        }

        /**
         * Causes this test to use the object returned by a call to the given method
         * in place of the class object.
         * @param methodName the name of the method to be called
         * @param args the arguments to pass when calling methodName
         * @return the TestSetup object used to call this method
         */
        public TestSetup replaceInstanceWithReturnFromMethod(String methodName, Object... args) {
            logger.fine(String.format("Replacing current instance with call to %s()", methodName));
            if (builder.hasFailed()) {
                logger.fine("Could not replace instance as test has already failed.");
                return this;
            }
            Object expectObj = builder.getExpectClassInstance();
            Object actualObj = builder.getActualClassInstance();
            Method expectMethod = TestUtils.getMethod(expectObj.getClass(), methodName, args);
            Method actualMethod = TestUtils.getMethod(actualObj.getClass(), methodName, args);
            Object expectNewObj = TestUtils.callMethodAndReturn(expectObj, expectMethod, args);
            Object actualNewObj = TestUtils.callMethodAndReturn(actualObj, actualMethod, args);
            sb.append("   Retrieving the object returned by a call to the <")
                    .append(methodName).append("> method\n    ");
            String argString = TestUtils.argArray2String(TestUtils.parseActualArgs(args));
            sb.append(argString).append("\n");
            builder.setExpectClassInstance(expectNewObj);
            builder.setActualClassInstance(actualNewObj);
            return this;
        }

        /**
         * Causes this test to use the given field (instance variable) in place of the class
         * object. Test MAY fail if the given instance variable is null.
         * @param fieldName the name of the field to replace the class object
         * @return the TestSetup object used to call this method
         */
        public TestSetup replaceInstanceWithField(String fieldName) {
            logger.fine(String.format("Replacing current instance with field %s", fieldName));
            if (builder.hasFailed()) {
                logger.fine("Could not replace instance as test has already failed.");
                return this;
            }
            sb.append("   Retrieving the <").append(fieldName).append("> field\n");
            Object expectObj = builder.getExpectClassInstance();
            Object actualObj = builder.getActualClassInstance();
            Object expectField = TestUtils.getFieldObject(expectObj, fieldName);
            Object actualField = null;
            try {
                actualField = TestUtils.getFieldObject(actualObj, fieldName);
            } catch (Exception e) {
                logger.log(Level.SEVERE, "Exception thrown while trying to replace instance", e);
                String msg = String.format("Test failed due to problem field %s in %s",
                        fieldName, expectObj.getClass());
                builder.setFailed(msg);
            }
            builder.setExpectClassInstance(expectField);
            builder.setActualClassInstance(actualField);
            return this;
        }

        public TestSetup setFieldValue(String fieldName, Object value) {
            logger.fine(String.format("Setting field %s to %s", fieldName, value));
            builder.setFieldValue(fieldName, value);
            return this;
        }
    }

    /* ****************************************************************************************** */
    /* Test properties section */
    /* ****************************************************************************************** */

    /**
     * Returns a {@link FactoryProperties} object that can be used to set or reset any static
     * fields (test properties) for re-use in test creation. Set multiple fields to simplify the
     * test creation process. Example usage:
     *
     * <pre>
     * {@code
     * TestFactory factory = new TestFactory();
     *
     * factory.props().name("Exercise 1: AddingMachine");
     * factory.props().className("AddingMachine");
     * factory.props().constructorArgs(); // no args
     * factory.props().methodName("add");
     * factory.props().hint("Don't forget to add the numbers");
     * factory.props().useGeneratedDescription();
     * factory.props().testingReturnValue();
     * factory.props().maxScore(1);
     *
     * factory.preparedTest().withMethodArgs(1, 1).build();
     * factory.preparedTest().withMethodArgs(5, 5).build();
     * factory.preparedTest().withMethodArgs(-1, 1).build();
     *
     * factory.startTest();
     * }
     * </pre>
     * @return the object used to call setter methods
     */
    public FactoryProperties props() {
        logger.finest("Factory props object requested");
        return props;
    }

    public static class FactoryProperties {
        private FactoryProperties(){
            logger.finer("Factory props object initialized");
        }

        /**
         * Resets any previously set static fields to null or 0.
         */
        public void resetStaticFields() {
            logger.fine("Resetting all static fields");
            TestBuilder.resetStaticFields();
        }

        /**
         * Sets the name of any tests prepared using the currently active static fields.
         * @param name the name of any tests prepared using the currently active static fields
         */
        public void name(String name) {
            logger.finest(String.format("Setting the static test name to %s", name));
            TestBuilder.setStaticName(name);
        }

        /**
         * Sets the extra message to be added before the test description of any tests
         * prepared using the currently active static fields. This can be used to add an
         * additional note describing the test while still using the automatically generated
         * description.
         * @param note the extra message to be added before the test description
         */
        public void note(String note) {
            logger.finest(String.format("Setting the static test note to %s", note));
            TestBuilder.setStaticNote(note);
        }

        /**
         * Sets the random number generator seed for any tests prepared using the currently
         * active static fields. After setting this seed, any constructors or method calls
         * reset the seed between the solution and submission calls. Currently only StdRandom
         * is supported.
         *
         * @param seed the seed to use for random number generators.
         */
        public void setRandomSeed(long seed) {
            logger.finest(String.format("Setting the static test random seed to %d", seed));
            TestBuilder.setRandomSeed(seed);
        }

        /**
         * Sets the name of the class to be tested for
         * any tests prepared using the currently active static fields.
         * @param className the name of the class for any tests prepared using the
         *                  currently active static fields
         */
        public void className(String className) {
            logger.finest(String.format("Setting the static class name to %s", className));
            TestBuilder.setStaticClassName(className);
        }

        /**
         * Sets the constructor arguments for the class for
         * any tests prepared using the currently active static fields.
         * @param args the constructor arguments for the class for
         *             any tests prepared using the currently active static fields
         */
        public void constructorArgs(Object... args) {
            logger.finest("Setting the static constructor args (omitted)");
            TestBuilder.setStaticClassArgs(args);
        }

        /**
         * Sets the name of the method being tested by
         * any tests prepared using the currently active static fields.
         * @param methodName the name of the method being tested by
         *                   any tests prepared using the currently active static fields
         */
        public void methodName(String methodName) {
            logger.finest(String.format("Setting the static method name to %s", methodName));
            TestBuilder.setStaticMethodName(methodName);
        }

        /**
         * Sets the arguments to be used to call the method being tested by
         * any tests prepared using the currently active static fields.
         * @param args the arguments to be used to call the method being tested by
         *             any tests prepared using the currently active static fields
         */
        public void methodArgs(Object... args) {
            logger.finest("Setting the static method args (omitted)");
            TestBuilder.setStaticMethodArgs(args);
        }

        /**
         * Sets the max score for any tests prepared using the currently active static fields.
         * @param maxScore the max score for any tests prepared using the
         *                 currently active static fields
         */
        public void maxScore(double maxScore) {
            logger.finest(String.format("Setting the static max score to %.2f", maxScore));
            TestBuilder.setStaticMaxScore(maxScore);
        }

        /**
         * Sets the hint to be provided to a student upon test failure for
         * any tests prepared using the currently active static fields.
         * @param hint the hint to be provided to the student upon test failure for
         *             any tests prepared using the currently active static fields
         */
        public void hint(String hint) {
            logger.finest("Setting the static hint (omitted)");
            TestBuilder.setStaticHint(hint);
        }

        /**
         * Specifies that standard output will be basis of
         * any tests prepared using the currently active static fields.
         */
        public void testingStdOut() {
            logger.finest("Setting static test type flag to standard output");
            TestBuilder.setStaticTestingStdOut();
        }

        /**
         * Specifies that the tested method's return value will be the basis of
         * any tests prepared using the currently active static fields
         */
        public void testingReturnValue() {
            logger.finest("Setting static test type flag to return value");
            TestBuilder.setStaticTestingReturnValue();
        }

        /**
         * Specifies that any tests prepared using the currently active static fields will
         * be looking for an exception to be thrown in the constructor. This requires an exception
         * type be specified, either using these props() setter methods or during the
         * preparedTest() method chain.
         */
        public void testingCornerCaseForConstructor() {
            logger.finest("Setting static test type flag to corner case constructor");
            TestBuilder.setStaticTestingCornerCaseForConstructor();
        }

        /**
         * Specifies that any tests prepared using the currently active static fields will
         * be looking for an exception to be thrown in a method call. This requires an exception
         * type be specified, either using these props() setter methods or during the
         * preparedTest() method chain.
         */
        public void testingCornerCaseForMethod() {
            logger.finest("Setting static test type flag to corner case method");
            TestBuilder.setStaticTestingCornerCaseForMethod();
        }

        /**
         * Specifies that any tests prepared using the currently active static fields will
         * be checking the class's iterator.
         */
        public void testingIterator() {
            logger.finest("Setting static test type flag to iterator");
            TestBuilder.setStaticTestingIterator();
        }

        /**
         * Specifies that any tests prepared using the currently active static fields will
         * be checking one of the class's field values.
         */
        public void testingFieldValue() {
            logger.finest("Setting static test type flag to field value");
            TestBuilder.setStaticTestingFieldValue();
        }

        /**
         * Specifies that any tests prepared using the currently active static fields will
         * be checking one of the class's field values as a node tree (recursively checks
         * all values).
         */
        public void testingNodeTree() {
            logger.finest("Setting static test type flag to node tree");
            TestBuilder.setStaticTestingNodeTree();
        }

        /**
         * Specifies that any tests prepared using the currently active static fields will
         * be calling the class's main method.
         */
        public void testingMainMethod() {
            logger.finest("Setting static test type flag to main method");
            TestBuilder.setStaticTestingMainMethod();
        }

        /**
         * Sets the description to be used for any tests prepared using
         * the currently active static fields.
         * @param description the description to be used for
         *                    any tests prepared using the currently active static fields
         */
        public void description(String description) {
            logger.finest("Setting static test description (omitted)");
            TestBuilder.setStaticDescription(description);
        }

        /**
         * Sets the standard input to be used for any tests prepared using
         * the currently active static fields.
         * @param input the file name to be used as standard input
         */
        public void stdIn(String input) {
            logger.finest(String.format("Setting static standard input to %s", input));
            TestBuilder.setStaticStandardIn(input);
        }

        /**
         * Sets the expected exception message that should be included with any exception thrown
         * during any tests prepared using the currently active static fields.
         * @param message the expected exception message that should be included
         */
        public void exceptionMessage(String message) {
            logger.finest(String.format("Setting static exception message to %s", message));
            TestBuilder.setStaticExceptionMessage(message);
        }

        /**
         * Sets the exception type that should be thrown during a corner case test for
         * any tests prepared using the currently active static fields.
         * @param exceptionType the exceptiont ype that should be thrown
         */
        public void exceptionType(Class<? extends Throwable> exceptionType) {
            logger.finest(String.format("Setting static expected exception to %s", exceptionType));
            TestBuilder.setStaticExceptionType(exceptionType);
        }

        /**
         * Sets whether or not the order in an iterable return type should be considered
         * when testing the return value of a method, where that return type is an object
         * which implements the Iterable interface.
         *
         * @param matters whether the order of the iterator matters
         */
        public void iterableOrderMatters(boolean matters) {
            logger.finest(String.format("Setting static flag iterable order matters to: %s", matters));
            TestBuilder.setStaticIterableOrderMatters(matters);
        }
    }

    /* ****************************************************************************************** */
    /* The below method runs all tests */
    /* ****************************************************************************************** */

    /**
     * Begins running the created tests. Currently all tests are executed using the Template
     * TestTemplate class.
     */
    public void startTest() {
        logger.info("Starting tests");
        SummaryGeneratingListener listener = new SummaryGeneratingListener();
        String name = "edu.umb.testutils.Template#startTest(edu.umb.testutils.Test)";
        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
                .selectors(selectMethod(name))
                .filters(excludeEngines("junit-vintage"))
                .build();
        Launcher launcher = LauncherFactory.create();
        TestPlan testPlan = launcher.discover(request);
        launcher.registerTestExecutionListeners(listener);
        launcher.execute(request);
        TestExecutionSummary summary = listener.getSummary();
        summary.printTo(new PrintWriter(System.err));
        summary.printFailuresTo(new PrintWriter(System.err));
//        if (summary.getFailures().size() > 0) {
//            System.err.println("failures:\n" + summary.getFailures().get(0).getException());
//            summary.getFailures().get(0).getException().printStackTrace();
//        }
//        System.err.println("Done with tests and printing summary");
    }
}
